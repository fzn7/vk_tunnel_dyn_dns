# /usr/local/openresty/nginx/conf/nginx.conf
worker_processes auto;

events { worker_connections 1024; }

http {
  lua_shared_dict dummy 1m;
  map $http_upgrade $connection_upgrade { default close; websocket upgrade; }

  server {
    listen 8080;

    # диагностика: текущий апстрим из файла
    location = /__upstream {
      default_type text/plain;
      content_by_lua_block {
        local f = io.open('/shared/current_url','r')
        local u = f and f:read('*l') or '(none)'
        if f then f:close() end
        ngx.say(u)
      }
    }

    location / {
      set $upstream_scheme '';
      set $upstream_host   '';
      set $upstream        '';

      rewrite_by_lua_block {
        local f = io.open('/shared/current_url','r')
        local url = f and f:read('*l') or nil
        if f then f:close() end
        if not url or url == '' then return ngx.exit(502) end
        local scheme, host = string.match(url, '^(https?)://([^/]+)')
        if not scheme then return ngx.exit(502) end
        ngx.var.upstream_scheme = scheme
        ngx.var.upstream_host   = host
        ngx.var.upstream        = scheme .. '://' .. host
      }

      proxy_http_version 1.1;
      proxy_set_header Host              $upstream_host;
      proxy_set_header Upgrade           $http_upgrade;
      proxy_set_header Connection        $connection_upgrade;
      proxy_set_header X-Forwarded-For   $proxy_add_x_forwarded_for;
      proxy_set_header X-Forwarded-Proto $scheme;
      proxy_set_header X-Forwarded-Host  $host;

      # HTTPS upstream
      proxy_ssl_server_name on;
      proxy_ssl_name $upstream_host;

      proxy_read_timeout 600s;
      proxy_connect_timeout 30s;
      proxy_send_timeout 600s;

      proxy_pass $upstream$request_uri;
    }
  }
}
